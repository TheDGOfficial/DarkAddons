package gg.darkaddons;

import net.minecraft.client.Minecraft;
import net.minecraft.profiler.Profiler;
import org.jetbrains.annotations.NotNull;

final class McProfilerHelper {
    /**
     * Private constructor since this class only contains static members.
     * <p>
     * Always throws {@link UnsupportedOperationException} (for when
     * constructed via reflection).
     */
    private McProfilerHelper() {
        super();

        throw Utils.staticClassException();
    }

    private static final boolean checkMainThread() {
        return Minecraft.getMinecraft().isCallingFromMinecraftThread();
    }

    @NotNull
    private static final Profiler getProfiler() {
        return Minecraft.getMinecraft().mcProfiler;
    }

    /**
     * Even though performance impact is minimal because we don't create a new ProfileSection everytime,
     * the compiler still generates try finally constructs on the generated bytecode, and try-finally isn't entirely
     * free of cost in terms of performance, even though minimal.
     * <p>
     * Therefore, this method can be used to check if startProfiling has any impact before calling it
     * and entering the try-with-resources scope.
     * @return True if Minecraft debug screen profiler is enabled, false otherwise.
     */
    static final boolean shouldProfile() {
        return McProfilerHelper.getProfiler().profilingEnabled;
    }

    /**
     * Starts a profiling section.
     * <p>
     * Warning 1: This method must be called from Client thread only, it will print a stack trace otherwise,
     * pointing to the offending caller (even if the profiler is not enabled).
     * <p>
     * Warning 2: Care must be taken to call {@link McProfilerHelper#endSection()} before the method returns.
     * Therefore, patterns such as like this one:
     * <pre>
     * {@code
     * McProfilerHelper.startSection("my_section");
     * if (!precondition) {
     *     return;
     * }
     * // .. section logic
     * McProfilerHelper.endSection();
     * }
     * </pre>
     * Would cause a leak in the profiler, potentially crashing the game or displaying results that don't make sense
     * or recurse infinitely, showing duplicate "root" entries (only when the profiler is enabled).
     * <p>
     * To fix this, you must invert the if statement like this:
     * <pre>
     * {@code
     * McProfilerHelper.startSection("my_section");
     * if (precondition) {
     *     // .. section logic
     * }
     * McProfilerHelper.endSection();
     * }
     * </pre>
     *
     * Or alternatively, add an endSection before each early return, like this:
     * <pre>
     * {@code
     * McProfilerHelper.startSection("my_section");
     * if (!precondition) {
     *     McProfilerHelper.endSection();
     *     return;
     * }
     * // .. section logic
     * McProfilerHelper.endSection();
     * }
     * </pre>
     * <p>
     * Warning 3: Even if using the above precautions, if an exception happens inside your section logic,
     * since the code flow will go back to the last method catching the exception, the {@link McProfilerHelper#endSection()}
     * call at the end of the section logic will not be called.
     * <p>
     * To fix this you can use {@link ProfileSection} wrapper, which wraps calls to {@link McProfilerHelper#endSection()} within an
     * {@link AutoCloseable}, that will close the section even in the case of exceptions.
     * <p>
     * Although having an exception, like the name implies, an exceptional case, so you might ignore this warning,
     * because {@link AutoCloseable}'s and finally blocks are not free performance wise either and increase class file size.
     *
     * @param sectionName The section name.
     */
    static final void startSection(@NotNull final String sectionName) {
        if (!McProfilerHelper.shouldProfile()) {
            return;
        }

        if (McProfilerHelper.checkMainThread()) {
            McProfilerHelper.getProfiler().startSection(sectionName);
        } else {
            throw new IllegalStateException("section with name " + sectionName + " tried to start itself on thread " + Thread.currentThread().getName() + " which is not the client thread");
        }
    }

    static final void endSection() {
        if (!McProfilerHelper.shouldProfile()) {
            return;
        }

        if (McProfilerHelper.checkMainThread()) {
            McProfilerHelper.getProfiler().endSection();
        } else {
            throw new IllegalStateException("a section tried to end itself on thread " + Thread.currentThread().getName() + " which is not the client thread");
        }
    }
}
